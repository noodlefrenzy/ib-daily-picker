"""
Recommendation domain models.

PURPOSE: Pydantic models for trade recommendations and signals
DEPENDENCIES: pydantic, decimal

ARCHITECTURE NOTES:
- Recommendations are generated by strategies
- Include entry, exit targets, and position sizing
- Track status from pending through executed
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from enum import Enum

from pydantic import BaseModel, Field, field_validator


class SignalType(str, Enum):
    """Type of trading signal."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    AVOID = "avoid"


class RecommendationStatus(str, Enum):
    """Status of a recommendation."""

    PENDING = "pending"
    EXECUTED = "executed"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class Recommendation(BaseModel):
    """Trade recommendation generated by a strategy."""

    id: str = Field(..., description="Unique recommendation identifier")
    symbol: str = Field(..., description="Stock ticker symbol")
    strategy_name: str = Field(..., description="Strategy that generated this")
    signal_type: SignalType = Field(..., description="Buy/sell/hold signal")
    entry_price: Decimal | None = Field(None, description="Suggested entry price")
    stop_loss: Decimal | None = Field(None, description="Stop loss price")
    take_profit: Decimal | None = Field(None, description="Take profit target")
    position_size: Decimal | None = Field(None, description="Suggested position size")
    confidence: Decimal = Field(
        default=Decimal("0.5"),
        description="Confidence score 0-1",
        ge=Decimal("0"),
        le=Decimal("1"),
    )
    reasoning: str | None = Field(None, description="Why this signal was generated")
    generated_at: datetime = Field(default_factory=datetime.utcnow, description="When generated")
    expires_at: datetime | None = Field(None, description="When signal expires")
    status: RecommendationStatus = Field(
        default=RecommendationStatus.PENDING, description="Current status"
    )

    @field_validator("symbol", mode="before")
    @classmethod
    def uppercase_symbol(cls, v: str) -> str:
        """Ensure symbol is uppercase."""
        return v.upper().strip()

    @field_validator("entry_price", "stop_loss", "take_profit", "position_size", mode="before")
    @classmethod
    def to_decimal(cls, v: float | str | Decimal | None) -> Decimal | None:
        """Convert to Decimal."""
        if v is None:
            return None
        if isinstance(v, Decimal):
            return v
        return Decimal(str(v))

    @field_validator("confidence", mode="before")
    @classmethod
    def to_decimal_confidence(cls, v: float | str | Decimal) -> Decimal:
        """Convert confidence to Decimal."""
        if isinstance(v, Decimal):
            return v
        return Decimal(str(v))

    @property
    def is_expired(self) -> bool:
        """Check if recommendation has expired."""
        if self.expires_at is None:
            return False
        return datetime.utcnow() > self.expires_at

    @property
    def risk_amount(self) -> Decimal | None:
        """Calculate risk amount (entry - stop loss)."""
        if self.entry_price is None or self.stop_loss is None:
            return None
        return abs(self.entry_price - self.stop_loss)

    @property
    def reward_amount(self) -> Decimal | None:
        """Calculate reward amount (take profit - entry)."""
        if self.entry_price is None or self.take_profit is None:
            return None
        return abs(self.take_profit - self.entry_price)

    @property
    def risk_reward_ratio(self) -> Decimal | None:
        """Calculate risk/reward ratio."""
        risk = self.risk_amount
        reward = self.reward_amount
        if risk is None or reward is None or risk == 0:
            return None
        return reward / risk

    @property
    def is_actionable(self) -> bool:
        """Check if recommendation can be acted upon."""
        return (
            self.status == RecommendationStatus.PENDING
            and not self.is_expired
            and self.signal_type in (SignalType.BUY, SignalType.SELL)
        )


class RecommendationBatch(BaseModel):
    """Batch of recommendations."""

    recommendations: list[Recommendation] = Field(default_factory=list)
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    strategy_name: str | None = Field(None, description="Source strategy")

    @property
    def count(self) -> int:
        """Number of recommendations."""
        return len(self.recommendations)

    @property
    def actionable_count(self) -> int:
        """Number of actionable recommendations."""
        return sum(1 for r in self.recommendations if r.is_actionable)

    def filter_by_signal(self, signal_type: SignalType) -> RecommendationBatch:
        """Filter by signal type."""
        return RecommendationBatch(
            recommendations=[r for r in self.recommendations if r.signal_type == signal_type],
            generated_at=self.generated_at,
            strategy_name=self.strategy_name,
        )

    def filter_actionable(self) -> RecommendationBatch:
        """Filter to only actionable recommendations."""
        return RecommendationBatch(
            recommendations=[r for r in self.recommendations if r.is_actionable],
            generated_at=self.generated_at,
            strategy_name=self.strategy_name,
        )

    def sort_by_confidence(self, descending: bool = True) -> RecommendationBatch:
        """Sort by confidence score."""
        sorted_recs = sorted(self.recommendations, key=lambda r: r.confidence, reverse=descending)
        return RecommendationBatch(
            recommendations=sorted_recs,
            generated_at=self.generated_at,
            strategy_name=self.strategy_name,
        )
